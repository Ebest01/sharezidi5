const express = require('express');
const mongoose = require('mongoose');
const path = require('path');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 5000;

console.log('[SERVER] Starting ShareZidi Production Server...');
console.log('[SERVER] Environment:', process.env.NODE_ENV);
console.log('[SERVER] Port:', PORT);

// Middleware
app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ extended: false, limit: "50mb" }));

// MongoDB Connection
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://shzmdb2:11xxshzMDB@sharezidi_v2_shzidi_mdb2:27017/?ssl=false';

async function connectMongoDB() {
  try {
    console.log('[MONGODB] Connecting to database...');
    await mongoose.connect(MONGODB_URI, {
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 10000,
    });
    console.log('[MONGODB] âœ… Connected successfully');
    return true;
  } catch (error) {
    console.error('[MONGODB] âŒ Connection failed:', error.message);
    return false;
  }
}

// User Schema
const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  username: { type: String },
  password: { type: String },
  transferCount: { type: Number, default: 0 },
  isPro: { type: Boolean, default: false },
  ipAddress: { type: String },
  country: { type: String },
  city: { type: String }
}, { timestamps: true });

const User = mongoose.model('User', userSchema);

// API Routes
app.get('/api/auth/user', async (req, res) => {
  const sessionId = req.headers.authorization?.replace('Bearer ', '') || 
                   req.headers.cookie?.match(/sessionId=([^;]+)/)?.[1];
  
  try {
    if (sessionId) {
      const user = await User.findOne({ username: sessionId });
      if (user) {
        return res.json({
          id: user._id.toString(),
          email: user.email,
          username: user.username,
          transferCount: user.transferCount,
          isPro: user.isPro,
          isGuest: false
        });
      }
    }
    
    res.json({
      id: 'guest',
      email: 'guest@sharezidi.com',
      transferCount: 0,
      isPro: false,
      isGuest: true
    });
  } catch (error) {
    console.error('[AUTH] Error:', error);
    res.json({
      id: 'guest',
      email: 'guest@sharezidi.com',
      transferCount: 0,
      isPro: false,
      isGuest: true
    });
  }
});

app.post('/api/register', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email || !email.includes('@')) {
      return res.status(400).json({ error: 'Valid email is required' });
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Generate password
    const password = Math.random().toString(36).slice(-8);
    const username = email.split('@')[0];

    const newUser = await new User({
      email,
      username,
      password,
      transferCount: 0,
      isPro: false
    }).save();

    console.log('[REGISTER] âœ… User created:', email);

    res.status(201).json({
      success: true,
      user: {
        id: newUser._id,
        email: newUser.email,
        username: newUser.username
      },
      generatedPassword: password,
      message: 'Registration successful! Save your password.'
    });

  } catch (error) {
    console.error('[REGISTER] Error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    const user = await User.findOne({ email });
    if (!user || user.password !== password) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    res.json({
      success: true,
      user: {
        id: user._id.toString(),
        email: user.email,
        username: user.username,
        transferCount: user.transferCount,
        isPro: user.isPro,
        isGuest: false
      },
      sessionToken: user.username
    });

  } catch (error) {
    console.error('[LOGIN] Error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

app.get('/api/dbtest/users', async (req, res) => {
  try {
    const users = await User.find({})
      .select('email username transferCount isPro createdAt')
      .sort({ createdAt: -1 })
      .limit(50);
    
    res.json({
      success: true,
      count: users.length,
      users
    });
  } catch (error) {
    console.error('[DBTEST] Error:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

app.get('/health', async (req, res) => {
  const dbConnected = mongoose.connection.readyState === 1;
  
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    database: dbConnected ? 'connected' : 'disconnected',
    port: PORT,
    environment: process.env.NODE_ENV
  });
});

// Serve static files
const publicPath = path.join(__dirname, 'dist', 'public');
console.log('[SERVER] Static files path:', publicPath);

// Serve assets
app.use('/assets', express.static(path.join(publicPath, 'assets')));

// Catch-all for SPA
app.get('*', (req, res) => {
  const indexPath = path.join(publicPath, 'index.html');
  
  if (fs.existsSync(indexPath)) {
    res.sendFile(indexPath);
  } else {
    res.status(404).json({ 
      error: 'Frontend not found',
      path: indexPath,
      exists: false
    });
  }
});

// Start server
async function startServer() {
  const dbConnected = await connectMongoDB();
  
  app.listen(PORT, '0.0.0.0', () => {
    console.log(`âœ… [SERVER] ShareZidi running on port ${PORT}`);
    console.log(`ğŸ“Š [DATABASE] ${dbConnected ? 'âœ… Connected' : 'âŒ Disconnected'}`);
    console.log(`ğŸŒ [HEALTH] http://localhost:${PORT}/health`);
    console.log(`ğŸ”— [APP] Ready to serve requests`);
  });
}

startServer().catch(console.error);